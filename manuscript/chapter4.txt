# 第4章 iOS プッシュ通知の基本的な実装方法

この章では、iOSアプリでプッシュ通知を受け取るために必要なdevice token(デバイストークン)を取得する手順について説明していきます。

## 4.1 device token(デバイストークン)とは？

次の章で詳しく説明しますが、プッシュ通知を発行する際に、その発行先をdevice tokenで指定します。device tokenは、端末・アプリごとに1意となっていて、1つの有効なdevice tokenへ発行した通知はただ1つの端末の特定の1つのアプリにのみ届くようになっています。また、そのアプリがアンインストールされた際などにそのdevice tokenは無効となり、そのdevice tokenへ向けてプッシュ通知を発行しても失敗し不達となります。

この章ではこのdevice tokenを取得する方法に絞って説明していきます。iOSアプリでのプッシュ通知周りの実装は多岐に渡りますが、それらは後の章で扱います。



## 4.2 Xcode プロジェクトの作成と設定

_これから説明するXcodeプロジェクトのサンプルは、サンプルコードの`NotificationExample.xcodeproj`プロジェクトの`Simple`ターゲットに含まれています。_

それでは、[iOS Certificates - Apple Developer](https://developer.apple.com/account/ios/certificate)で生成した各種ファイルを用いてXcodeでの作業を進めていきます。

### プロジェクトの作成

まずは、プロジェクトを作成します。形式は何でも良いですが、とりあえず一番シンプルな`Single View App`をオススメします。

![](images/chapter4/new_app1.png)

次に、適当なProduct Name(アプリ名)・Team([iOS Certificates - Apple Developer](https://developer.apple.com/account/ios/certificate)で利用したものを選択)を指定して新規アプリを作ります。

![](images/chapter4/new_app2.png)

### プッシュ通知対応のためのプロジェクト設定

まず、プロジェクト設定にて作成したアプリターゲットを選び、Generalタブにて、第3章で作成したものを設定します。

- Identity - Bundle Identifier: 作成したApp ID
- Signing - Team: 作成するのに使ったTeam名

![](images/chapter4/general.png)

どこかが間違えているとエラーが出てしまいますので、そのエラーメッセージを見たり第3章を再度見るなどして解決してください。

うまくいった場合は、隣のCapabilitiesタブにて、Push Notificationsという項目が現れます(逆にGeneralタブでの設定が正しくないと出てこないこともあります)。デフォルトはオフなので、オンに切り替えます。

![](images/chapter4/capabilities.png)

以上で、device tokenを得るための最低限の設定は完了です。

## 4.3 device tokenの取得

それでは、device tokenを取得するための最低限のコードを書いていきます。以下、サポートバージョンはiOS 10以上となります。

まず、`AppDelegate.swift`を開きます。そして、[UserNotifications](https://developer.apple.com/documentation/usernotifications)フレームワークをimportします。これは、iOS 10で新しくできた通知用のフレームワークで、それまでUIKitに包含されていた通知周りが切り出されて使いやすくなりました。

```swift
import UserNotifications
```

次に、`AppDelegate`クラスの[-application:didFinishLaunchingWithOptions:](https://developer.apple.com/documentation/uikit/uiapplicationdelegate/1622921-application?language=objc)という、アプリが終了した状態から起動される度に毎回初めに必ず呼ばれるメソッド内に通知許可を求める処理およびそれが許可されていた場合にdevice tokenをリクエストする処理を書きます。

```swift
func application(_ application: UIApplication,
                 didFinishLaunchingWithOptions launchOptions: [UIApplicationLaunchOptionsKey: Any]?) -> Bool {
    let userNotificationCenter = UNUserNotificationCenter.current()
    // C: あとで説明
    userNotificationCenter.delegate = self
    userNotificationCenter.requestAuthorization(options: [.alert, .badge, .sound]) { granted, error in
        // エラーの場合は出力
        logger.error(error)
        if !granted {
            // 許可されなかった場合は諦める
            return
        }
        // B: Main Thread Checkerに指摘されるので対応
        DispatchQueue.main.async {
            // A: 毎回起動する度に呼ぶ
            UIApplication.shared.registerForRemoteNotifications()
        }
    }
    return true
}
```

それでは、上記コードを解説していきます。

### A: 毎回起動する度に呼ぶ

一見、一回device token取得できれば、もう問い合わせる必要は無いのでは？と思ってしまいますが、公式ドキュメントにはdevice tokenは変更されるうるので起動する度に毎回問い合わせるように、と明記されています。

> Never cache device tokens in your app; instead, get them from the system when you need them. APNs issues a new device token to your app when certain events happen. The device token is guaranteed to be different, for example, when a user restores a device from a backup, when the user installs your app on a new device, and when the user reinstalls the operating system. Fetching the token, rather than relying on a cache, ensures that you have the current device token needed for your provider to communicate with APNs. When you attempt to fetch a device token but it has not changed, the fetch method returns quickly.
> [Local and Remote Notification Programming Guide: Configuring Remote Notification Support](https://developer.apple.com/library/content/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/HandlingRemoteNotifications.html#//apple_ref/doc/uid/TP40008194-CH6-SW1)

ただ、[観測ベースではiOS 9以上ではアプリ再インストールの時にdevice tokenが変わるようになっています](http://qiita.com/mono0926/items/9ef83c8b0de0e84118ac)。とはいえ、他のレアケースで変わり得るかもしれず、また今後のiOSバージョンで挙動が変わる可能性もあるので、ドキュメントに記載の通り、毎回起動する度にdevice tokenを問い合わせるのがセオリーです。

一方、毎回device tokenを問い合わせるとはいっても、必ずしもアプリ起動直後にプッシュ通知許可ダイアログ表示をするのが良いとは限らず、それについては後のUXの章で説明します。

### B: Main Thread Checkerに指摘されるので対応

筆者は、Xcode 8では`DispatchQueue.main.async`で囲まずに直接`registerForRemoteNotifications`を呼んでしまっていました。Xcode 9で[Main Thread Checker](https://developer.apple.com/documentation/code_diagnostics/main_thread_checker)という、`UIKit`などのメインスレッドから呼ばれる前提のものをバックグラウンドスレッドからアクセスがあった際に検知する仕組みが導入され、そこで指摘されたのでメインスレッドに戻す処理を入れました。UI更新では無いのであまり問題が無さそうで、かつ以前バックグランドから呼び出していた時も全く問題なく動いていたので必ずしも必要かは不明ですが、指摘通りにメインスレッドから呼び出すに越したことはないと思っています。

`UIApplication.shared.registerForRemoteNotifications()`でdevice tokenの取得処理が走り、結果として`AppDelegate`クラスの次のいずれかのメソッドが呼び出されます。

```
func application(_ application: UIApplication,
                  didFailToRegisterForRemoteNotificationsWithError error: Error) {
    // `registerForRemoteNotifications()`を契機に、
    // シミュレーター・設定の誤った実機実行ではこちらに到達
    logger.error(error)
}

func application(_ application: UIApplication,
                  didRegisterForRemoteNotificationsWithDeviceToken deviceToken: Data) {
    // `registerForRemoteNotifications()`を契機に、
    // 正しく設定された実機実行ではこちらに到達
    // http://qiita.com/mono0926/items/3cf0dca3029f32f54a09
    let token = deviceToken.map { String(format: "%.2hhx", $0) }.joined()
    logger.info("token: \(token)")
}
```

設定間違っている時のエラーを載せる